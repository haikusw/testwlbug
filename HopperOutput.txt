
The actual extension to String that I wrote via hopper, as built with 

swift-DEVELOPMENT-SNAPSHOT-2019-12-03-a-osx.pkg

toolchain.

is this pseudocode generated by Hopper from the binary:

(The compiler has reversed the tests so it's testing if it should use the code outside the library first and then the else
clause has the library dependent code).



int _$sSS9testwlbugE10stringHashSSyF(int arg0, int arg1) {
  intrinsic_movaps(var_20, 0x0);
  intrinsic_movaps(var_30, 0x0);
  intrinsic_movaps(var_50, 0x0);
  intrinsic_movaps(var_80, 0x0);
  intrinsic_movaps(var_90, 0x0);
  intrinsic_movaps(var_D0, 0x0);
  var_F0 = arg0;
  var_F8 = arg1;
  swift_bridgeObjectRetain(arg1);
  swift_bridgeObjectRetain(var_F8);
  var_30 = var_F0;
  var_28 = var_F8;
  rax = type metadata accessor for (0x0);
  rax = *(rax - 0x8);
  rsi = *(rax + 0x40);
  rsp = &stack[-824] - (rsi + 0xf & 0xfffffffffffffff0);
  var_110 = rax;
  var_128 = rsi;
  static (rsi + 0xf & 0xfffffffffffffff0, rsi);
  var_138 = lazy protocol witness table accessor for type Swift.String and conformance Swift.String : Swift.StringProtocol in Swift();
  rax = default argument 1 of (*type metadata for Swift.String);
  rdx = *type metadata for Swift.String;
  rax = (extension in Foundation):Swift.StringProtocol.data(using: (extension in Foundation):Swift.String.Encoding, allowLossyConversion: Swift.Bool) -> Foundation.Data?(r9, rax & 0xff, rdx, var_138);
  var_148 = rdx;
  var_150 = rax;
  (*(var_110 + 0x8))(r9, rcx);
  if ((var_148 & 0xff00000000000000) != 0xff00000000000000) {
    var_158 = var_150;
    var_160 = var_148;
    var_168 = var_160;
    var_170 = var_158;
    swift_bridgeObjectRelease(var_F8);
    if ((Swift._stdlib_isOSVersionAtLeast(0xa, 0xf, 0x0, var_168) & 0x1) == 0x0) {
      var_248 = Foundation.Data.base64EncodedData(default argument 0 of Foundation.Data.base64EncodedData(), var_170, var_168);
      static (&stack[-8] - (var_128 + 0xf & 0xfffffffffffffff0), var_128 + 0xf & 0xfffffffffffffff0);
      var_268 = (extension in Foundation):Swift.String.init(data: __shared Foundation.Data, encoding: (extension in Foundation):Swift.String.Encoding) -> Swift.String?(var_248, var_168, &stack[-8] - (var_128 + 0xf & 0xfffffffffffffff0));
      var_270 = &stack[-8] - (var_128 + 0xf & 0xfffffffffffffff0);
      outlined consume of Foundation.Data._Representation(var_248, var_168);
      if (var_270 != 0x0) {
        var_A0 = var_268;
        (extension in Swift):Swift.BidirectionalCollection.suffix(Swift.Int) -> A.SubSequence(0x80, *type metadata for Swift.String, lazy protocol witness table accessor for type Swift.String and conformance Swift.String : Swift.BidirectionalCollection in Swift(), &var_A0);
              var_298 = var_70;
              var_2A0 = var_68;
              var_2A8 = var_60;
              var_2B0 = var_58;
          }
          else {
              var_298 = 0x0;
              var_2A0 = 0x0;
              var_2A8 = 0x0;
              var_2B0 = 0x0;
          }
          var_2B8 = var_2B0;
          var_2C0 = var_2A8;
          var_2C8 = var_2A0;
          var_2D0 = var_298;
          if (var_2B0 != 0x0) {
              var_2D8 = var_2D0;
              var_2E0 = var_2C8;
              var_2E8 = var_2C0;
              var_2F0 = var_2B8;
              rax = Swift.String.init(var_2D8, var_2E0, var_2E8, var_2F0);
              rdi = var_28;
              var_30 = rax;
              var_28 = var_2E8;
              swift_bridgeObjectRelease(rdi);
              swift_bridgeObjectRelease(var_2F0);
          }
      }
      else {
          rax = type metadata accessor for CryptoKit.Insecure.SHA1Digest(0x0, 0xf, 0x0);
          rcx = rax;
          rax = *(rax - 0x8);
          rsi = *(rax + 0x40);
          var_180 = &stack[-8];
          var_190 = rcx;
          var_198 = rax;
          var_1A0 = &stack[-8] - (rsi + 0xf & 0xfffffffffffffff0);
          rax = type metadata accessor for CryptoKit.Insecure.SHA1(0x0, &stack[-8] - (rsi + 0xf & 0xfffffffffffffff0));
          var_B8 = var_170;
          static (&var_B8, rax, *type metadata for Foundation.Data, lazy protocol witness table accessor for type CryptoKit.Insecure.SHA1 and conformance CryptoKit.Insecure.SHA1 : CryptoKit.HashFunction in CryptoKit(), lazy protocol witness table accessor for type Foundation.Data and conformance Foundation.Data : Foundation.DataProtocol in Foundation());
          var_D0 = (extension in CryptoKit):CryptoKit.Digest.makeIterator() -> Swift.IndexingIterator<[Swift.UInt8]>(var_190, lazy protocol witness table accessor for type CryptoKit.Insecure.SHA1Digest and conformance CryptoKit.Insecure.SHA1Digest : CryptoKit.Digest in CryptoKit());
          do {
              Swift.IndexingIterator.next(___swift_instantiateConcreteTypeFromMangledName(_$ss16IndexingIteratorVySays5UInt8VGGMD));
              var_1D9 = var_D8;
              if ((var_D7 & 0x1) != 0x0) {
                break;
              }
              var_1DA = var_1D9;
              var_1E8 = Swift.String.init("%02x", 0x4, 0x1);
              rax = ___swift_instantiateConcreteTypeFromMangledName(_$ss7CVarArg_pMD);
              rax = Swift._allocateUninitializedArray<A>(0x1, rax);
              rcx = *protocol witness table for Swift.UInt8 : Swift.CVarArg in Swift;
              var_E8 = var_1DA;
              *(int64_t *)0x19 = *type metadata for Swift.UInt8;
              *(int64_t *)0x21 = rcx;
              var_1F8 = rax;
              var_210 = lazy protocol witness table accessor for type Swift.UInt8 and conformance Swift.UInt8 : Swift.FixedWidthInteger in Swift();
              var_218 = lazy protocol witness table accessor for type Swift.UInt8 and conformance Swift.UInt8 : Swift.UnsignedInteger in Swift();
              rax = lazy protocol witness table accessor for type Swift.UInt8 and conformance Swift.UInt8 : Swift.BinaryInteger in Swift();
              rcx = *type metadata for Swift.UInt8;
              (extension in Swift):Swift.UnsignedInteger< where A: Swift.FixedWidthInteger>.init<A where A1: Swift.BinaryInteger>(A1) -> A(&var_E8, rcx, rcx, var_210, var_218, rax);
              var_230 = (extension in Foundation):Swift.String.init(format: __shared Swift.String, _: Swift.CVarArg...) -> Swift.String(var_1E8, 0x1, var_1F8);
              swift_bridgeObjectRelease(0x1);
              rax = static Swift.String.+= infix(&var_30, var_230, var_1F8);
              swift_bridgeObjectRelease(var_1F8);
          } while (true);
          outlined destroy of Swift.IndexingIterator<[Swift.UInt8]>(&var_D0);
          (*(var_198 + 0x8))(var_1A0, var_190);
      }
      swift_bridgeObjectRetain(var_28);
      outlined consume of Foundation.Data._Representation(var_170, var_168);
      outlined destroy of Swift.String(&var_30);
      var_318 = var_30;
      var_320 = var_28;
  }
  else {
      outlined destroy of Swift.String(&var_30);
      var_318 = var_F0;
      var_320 = var_F8;
  }
  rax = var_318;
  return rax;
}






but later in the file there's these two routines that are referencing things in the module/library and that don't seem to be in the protected code block:



int _$s9CryptoKit8InsecureO10SHA1DigestVAeA0E0AAWl() {
  rsp = rsp - 0x18;
  rax = *lazy protocol witness table cache variable for type CryptoKit.Insecure.SHA1Digest and conformance CryptoKit.Insecure.SHA1Digest : CryptoKit.Digest in CryptoKit;
  var_8 = rax;
  if (rax == 0x0) {
      rax = type metadata accessor for CryptoKit.Insecure.SHA1Digest(0xff);
      rax = swift_getWitnessTable(*protocol conformance descriptor for CryptoKit.Insecure.SHA1Digest : CryptoKit.Digest in CryptoKit, rax, rax);
      *lazy protocol witness table cache variable for type CryptoKit.Insecure.SHA1Digest and conformance CryptoKit.Insecure.SHA1Digest : CryptoKit.Digest in CryptoKit = rax;
      var_8 = rax;
  }
  rax = var_8;
  return rax;
}

and

int _$s9CryptoKit8InsecureO4SHA1VAeA12HashFunctionAAWl() {
  rsp = rsp - 0x18;
  rax = *lazy protocol witness table cache variable for type CryptoKit.Insecure.SHA1 and conformance CryptoKit.Insecure.SHA1 : CryptoKit.HashFunction in CryptoKit;
  var_8 = rax;
  if (rax == 0x0) {
      rax = type metadata accessor for CryptoKit.Insecure.SHA1(0xff);
      rax = swift_getWitnessTable(*protocol conformance descriptor for CryptoKit.Insecure.SHA1 : CryptoKit.HashFunction in CryptoKit, rax, rax);
      *lazy protocol witness table cache variable for type CryptoKit.Insecure.SHA1 and conformance CryptoKit.Insecure.SHA1 : CryptoKit.HashFunction in CryptoKit = rax;
      var_8 = rax;
  }
  rax = var_8;
  return rax;
}
